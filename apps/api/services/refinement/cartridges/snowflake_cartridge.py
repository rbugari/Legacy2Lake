from pathlib import Path
from typing import Dict, Any, List
from .base_cartridge import Cartridge

class SnowflakeCartridge(Cartridge):
    """
    Generates Snowflake (Snowpark Python + SQL) code for Medallion Architecture.
    """

    def get_file_extension(self) -> str:
        return ".py"

    def generate_scaffolding(self) -> Dict[str, str]:
        """Generates config.py and utils.py tailored for Snowflake."""
        naming = self.registry.get("naming", {})
        
        s_bronze = naming.get("bronze_schema", "BRONZE_RAW")
        s_silver = naming.get("silver_schema", "SILVER_CURATED")
        s_gold = naming.get("gold_schema", "GOLD_BUSINESS")
        
        config_content = f"""# Snowflake Medallion Configuration
import snowflake.snowpark as snowpark

class Config:
    # Schemas (Snowflake calls them Schemas, Top level is Database)
    SCHEMA_BRONZE = "{s_bronze}"
    SCHEMA_SILVER = "{s_silver}"
    SCHEMA_GOLD = "{s_gold}"

    @staticmethod
    def get_session():
        # Assumes running inside Snowflake (Stored Proc) or properly configured client
        return snowpark.Session.builder.getOrCreate()
"""

        utils_content = """# Common Utility Functions for Snowpark
from snowflake.snowpark.functions import current_timestamp, lit

def add_ingestion_metadata(df):
    return df.with_column("_INGESTION_TIMESTAMP", current_timestamp()) \\
             .with_column("_SOURCE_SYSTEM", lit("SSIS_MIGRATION"))
"""
        return {
            "config.py": config_content,
            "utils.py": utils_content
        }

    def generate_bronze(self, table_metadata: Dict[str, Any]) -> str:
        source_path = Path(table_metadata.get("source_path", "unknown_source.py"))
        original_code = table_metadata.get("original_code", "")
        
        # Disable original code execution if possible or wrap it
        processed_lines = []
        for line in original_code.splitlines():
            if any(x in line for x in [".write", ".save", "saveAsTable", "display("]):
                processed_lines.append(f"# [DISABLED_BY_ARCHITECT] {line}")
            else:
                processed_lines.append(line)
        original_code_safe = "\n".join(processed_lines)
        
        return f"""# BRONZE LAYER INGESTION (SNOWFLAKE)
# Generated by Shift-T Architect Agent
# Source: {source_path.name}

from config import Config
from utils import add_ingestion_metadata
import snowflake.snowpark.functions as F
from snowflake.snowpark import Session

def main(session: Session):
    # [ORIGINAL READ LOGIC (Adapted)]
    # Assuming original code creates a dataframe 'df'
    {original_code_safe}
    
    # Check if df exists
    if 'df' not in locals():
        return "No DataFrame 'df' found in source script."

    df_bronze = add_ingestion_metadata(df)

    # Write to Snowflake Table
    target_table = f"{{Config.SCHEMA_BRONZE}}.{source_path.stem.upper()}"
    df_bronze.write.mode("append").save_as_table(target_table)
    
    return f"Successfully ingested {{target_table}}"
"""

    def generate_silver(self, table_metadata: Dict[str, Any]) -> str:
        source_path = Path(table_metadata.get("source_path", "unknown.py"))
        output_table_name = table_metadata.get("output_table_name", source_path.stem)
        pk_columns = table_metadata.get("pk_columns", ["ID"])
        if isinstance(pk_columns, str): pk_columns = [pk_columns]
        
        # Snowpark Merge syntax is slightly different
        merge_condition = " AND ".join([f"target.{pk} = source.{pk}" for pk in pk_columns])
        
        return f"""# SILVER LAYER TRANSFORMATION (SNOWFLAKE)
# Generated by Shift-T Architect Agent
# Source: {source_path.name}

from config import Config
import snowflake.snowpark.functions as F
from snowflake.snowpark import Session

def main(session: Session):
    # Read Bronze
    df_bronze = session.table(f"{{Config.SCHEMA_BRONZE}}.{source_path.stem.upper()}")
    
    # Deduplicate (Window function adaptation or drop_duplicates if supported)
    # Snowpark drop_duplicates is supported
    df_clean = df_bronze.drop_duplicates({pk_columns})

    # Merge (Upsert)
    target_table_name = f"{{Config.SCHEMA_SILVER}}.{output_table_name.upper()}"
    
    # Check existence logic omitted for brevity, assuming table exists or created if not
    # Ideally use MERGE
    
    # Start Merge
    # Need reference to target table object
    try:
        target = session.table(target_table_name)
        target.merge(
            df_clean,
            (F.col(f"target.{pk_columns[0]}") == F.col(f"source.{pk_columns[0]}")), # Simplified condition
            [F.when_matched().update_to_source(), F.when_not_matched().insert_to_source()]
        )
    except Exception as e:
        # Fallback to overwrite/create if table doesn't exist
        df_clean.write.mode("overwrite").save_as_table(target_table_name)

    return f"Updated {{target_table_name}}"
"""

    def generate_gold(self, table_metadata: Dict[str, Any]) -> str:
        source_path = Path(table_metadata.get("source_path", "unknown.py"))
        output_table_name = table_metadata.get("output_table_name", source_path.stem)
        table_type = table_metadata.get("table_type", "DIMENSION")
        
        logic_comment = "# Gold Logic: Business-ready projection."
        select_logic = "df_silver.select(F.col(\"*\"))"
        
        return f"""# GOLD LAYER - BUSINESS VIEW (SNOWFLAKE)
# Generated by Shift-T Architect Agent
# Source: {source_path.name}

from config import Config
import snowflake.snowpark.functions as F
from snowflake.snowpark import Session

def main(session: Session):
    target_silver_table = f"{{Config.SCHEMA_SILVER}}.{source_path.stem.upper()}"
    df_silver = session.table(target_silver_table)

    {logic_comment}
    df_gold = {select_logic}

    # Write to Gold
    target_gold_table = f"{{Config.SCHEMA_GOLD}}.{output_table_name.upper()}"
    df_gold.write.mode("overwrite").save_as_table(target_gold_table)
    
    return f"Updated {{target_gold_table}}"
"""

    def generate_bronze_sql(self, table_metadata: Dict[str, Any]) -> str:
        """Generates pure SQL for Bronze layer."""
        source_path = Path(table_metadata.get("source_path", "unknown"))
        target_table = f"{{Config.SCHEMA_BRONZE}}.{source_path.stem.upper()}"
        # Simplified SQL representation
        return f"""-- BRONZE LAYER (SQL)
-- Source: {source_path.name}
-- Target: {target_table}

-- Assuming Stage is configured
COPY INTO {target_table}
FROM @BySourceStage/{source_path.stem}
FILE_FORMAT = (TYPE = CSV);
"""

    def generate_silver_sql(self, table_metadata: Dict[str, Any]) -> str:
        """Generates pure SQL for Silver layer."""
        source_path = Path(table_metadata.get("source_path", "unknown"))
        output_table_name = table_metadata.get("output_table_name", source_path.stem)
        pk_columns = table_metadata.get("pk_columns", ["ID"])
        if isinstance(pk_columns, str): pk_columns = [pk_columns]
        
        target_bronze = f"{{Config.SCHEMA_BRONZE}}.{source_path.stem.upper()}"
        target_silver = f"{{Config.SCHEMA_SILVER}}.{output_table_name.upper()}"
        
        join_cond = " AND ".join([f"s.{pk} = t.{pk}" for pk in pk_columns])
        
        return f"""-- SILVER LAYER (SQL)
-- Target: {target_silver}

MERGE INTO {target_silver} AS t
USING (
    SELECT DISTINCT * FROM {target_bronze}
) AS s
ON {join_cond}
WHEN MATCHED THEN UPDATE SET
    t.matches = s.matches -- Placeholder
WHEN NOT MATCHED THEN INSERT
    VALUES (s.*);
"""

    def generate_gold_sql(self, table_metadata: Dict[str, Any]) -> str:
        """Generates pure SQL for Gold layer."""
        source_path = Path(table_metadata.get("source_path", "unknown"))
        output_table_name = table_metadata.get("output_table_name", source_path.stem)
        
        target_silver = f"{{Config.SCHEMA_SILVER}}.{source_path.stem.upper()}"
        target_gold = f"{{Config.SCHEMA_GOLD}}.{output_table_name.upper()}"
        
        return f"""-- GOLD LAYER (SQL)
-- Target: {target_gold}

CREATE OR REPLACE TABLE {target_gold} AS
SELECT *
FROM {target_silver};
"""

    def generate_orchestration(self, tables_metadata: List[Dict[str, Any]]) -> str:
        """Generates Snowflake Tasks for orchestration."""
        sql_tasks = f"""-- SNOWFLAKE ORCHESTRATION TASKS
-- Generated for Project: {self.project_id}

CREATE OR REPLACE TASK TSK_ROOT_{self.project_id}
  WAREHOUSE = COMPUTE_WH
  SCHEDULE = 'USING CRON 0 0 * * * UTC'
AS
  SELECT CURRENT_TIMESTAMP();

"""
        for table in tables_metadata:
            name = table['table_name'].upper()
            sql_tasks += f"""
-- Path for {name}
CREATE OR REPLACE TASK TSK_{name}_BRONZE
  WAREHOUSE = COMPUTE_WH
  AFTER TSK_ROOT_{self.project_id}
AS
  CALL PROCS.RUN_BRONZE_{name}();

CREATE OR REPLACE TASK TSK_{name}_SILVER
  WAREHOUSE = COMPUTE_WH
  AFTER TSK_{name}_BRONZE
AS
  CALL PROCS.RUN_SILVER_{name}();

CREATE OR REPLACE TASK TSK_{name}_GOLD
  WAREHOUSE = COMPUTE_WH
  AFTER TSK_{name}_SILVER
AS
  CALL PROCS.RUN_GOLD_{name}();
"""
        sql_tasks += f"\n-- Resume tasks\nALTER TASK TSK_ROOT_{self.project_id} RESUME;"
        return sql_tasks

